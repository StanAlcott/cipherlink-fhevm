"use client";

import { useCallback, useEffect, useState, useRef } from "react";
import { Contract, ethers } from "ethers";
import { useWallet } from "./useWallet";
import { FhevmJS } from "../fhevm/fhevm";
import { STORAGE_KEYS } from "../fhevm/constants";
import type {
  EncryptedMessage,
  DecryptedMessage,
  MessageStatus,
  FhevmDecryptionSignature,
} from "../fhevm/types";

// These will be generated by genabi.mjs
let CipherLinkABI: any;
let getCipherLinkAddress: (chainId: number) => string;

// Dynamic import for generated ABI (will be available after genabi runs)
async function loadContractInfo() {
  try {
    const { CipherLinkABI: abi } = await import("../abi/CipherLinkABI");
    const { getCipherLinkAddress: getAddress } = await import("../abi/CipherLinkAddresses");
    return { abi: abi.abi, getAddress };
  } catch (error) {
    console.error("Failed to load contract ABI. Please run 'npm run genabi' first.");
    throw new Error("Contract ABI not found. Run 'npm run genabi' to generate ABI files.");
  }
}

export function useCipherLink() {
  const { isConnected, chainId, signer, account, provider, rawProvider } = useWallet();
  const [contract, setContract] = useState<Contract | null>(null);
  const [fhevmInstance, setFhevmInstance] = useState<any>(null);
  const [isInitializing, setIsInitializing] = useState(false);
  const [initError, setInitError] = useState<Error | null>(null);
  
  // Message state
  const [messages, setMessages] = useState<Map<string, EncryptedMessage>>(new Map());
  const [decryptedMessages, setDecryptedMessages] = useState<Map<string, string>>(new Map());
  const [isLoadingMessages, setIsLoadingMessages] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [isDecrypting, setIsDecrypting] = useState(false);
  
  // Contract and FHEVM initialization
  const fhevmRef = useRef<FhevmJS | null>(null);

  const initializeContract = useCallback(async () => {
    if (!isConnected || !chainId || !signer || initError) {
      return;
    }

    setIsInitializing(true);
    setInitError(null);

    try {
      // Load contract ABI and address
      const { abi, getAddress } = await loadContractInfo();
      CipherLinkABI = abi;
      getCipherLinkAddress = getAddress;

      const contractAddress = getCipherLinkAddress(chainId);
      const contractInstance = new Contract(contractAddress, CipherLinkABI, signer);
      
      setContract(contractInstance);

      // Initialize FHEVM
      if (!fhevmRef.current) {
        fhevmRef.current = new FhevmJS();
      }

      const fhevmInst = await fhevmRef.current.createInstance({
        provider: rawProvider, // Use rawProvider instead of BrowserProvider
        chainId,
      });

      setFhevmInstance(fhevmInst);
      console.log("‚úÖ CipherLink initialized successfully");
      
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      setInitError(err);
      console.error("‚ùå CipherLink initialization failed:", err);
    } finally {
      setIsInitializing(false);
    }
  }, [isConnected, chainId, signer, provider, rawProvider, initError]);

  // Initialize when wallet connects
  useEffect(() => {
    if (isConnected && chainId && signer) {
      initializeContract();
    } else {
      // Reset state when wallet disconnects
      setContract(null);
      setFhevmInstance(null);
      setMessages(new Map());
      setDecryptedMessages(new Map());
      if (fhevmRef.current) {
        fhevmRef.current.reset();
      }
    }
  }, [isConnected, chainId, signer, initializeContract]);

  // Utility functions
  const getDecryptionSignatureKey = useCallback((address: string): string => {
    return `${STORAGE_KEYS.FHEVM_DECRYPTION_SIGNATURE_PREFIX}${address}`;
  }, []);

  const getStoredDecryptionSignature = useCallback(async (contractAddress: string): Promise<any> => {
    // For now, always generate new signature to avoid format mismatch issues
    // TODO: Implement proper signature caching later
    return null;
  }, []);

  const generateAndStoreDecryptionSignature = useCallback(async (contractAddress: string): Promise<any> => {
    if (!fhevmInstance || !account || !signer) {
      throw new Error("FHEVM instance, account, or signer not available");
    }

    console.log("Generating new decryption signature...");
    
    // Use the reference project approach with FhevmDecryptionSignature
    const { FhevmDecryptionSignature } = await import("../fhevm/FhevmDecryptionSignature");
    const { GenericStringStorage } = await import("../fhevm/GenericStringStorage");
    
    const storage = new GenericStringStorage();
    
    const sig = await FhevmDecryptionSignature.loadOrSign(
      fhevmInstance,
      [contractAddress],
      signer,
      storage
    );
    
    if (!sig) {
      throw new Error("Failed to generate decryption signature");
    }
    
    // Return the FhevmDecryptionSignature object directly
    return sig;
  }, [fhevmInstance, account, signer]);

  // Convert string to padded bytes for euint256
  const stringToUint256 = useCallback((str: string): bigint => {
    const bytes = ethers.toUtf8Bytes(str);
    if (bytes.length > 32) {
      throw new Error("Message too long (max 32 bytes)");
    }
    
    const paddedBytes = new Uint8Array(32);
    paddedBytes.set(bytes);
    
    return BigInt(ethers.hexlify(paddedBytes));
  }, []);

  // Convert uint256 back to string
  const uint256ToString = useCallback((value: bigint): string => {
    const hex = "0x" + value.toString(16).padStart(64, '0');
    const bytes = ethers.getBytes(hex);
    
    // Find null terminator
    let length = 0;
    for (let i = 0; i < bytes.length; i++) {
      if (bytes[i] === 0) break;
      length++;
    }
    
    return ethers.toUtf8String(bytes.slice(0, length));
  }, []);

  // Send encrypted message
  const sendMessage = useCallback(async (
    recipient: string,
    content: string
  ): Promise<{ success: boolean; messageId?: string; error?: Error }> => {
    if (!contract || !fhevmInstance || !account) {
      return { success: false, error: new Error("Not initialized") };
    }

    if (!ethers.isAddress(recipient)) {
      return { success: false, error: new Error("Invalid recipient address") };
    }

    if (content.length === 0) {
      return { success: false, error: new Error("Message content cannot be empty") };
    }

    if (content.length > 32) {
      return { success: false, error: new Error("Message too long (max 32 characters)") };
    }

    setIsSending(true);

    try {
      // Convert message to uint256
      const messageValue = stringToUint256(content);

      // Create encrypted input
      const encryptedInput = fhevmInstance.createEncryptedInput(
        await contract.getAddress(),
        account
      );
      encryptedInput.add256(messageValue);
      const { handles, inputProof } = await encryptedInput.encrypt();

      console.log("üì§ Sending encrypted message...");
      console.log("üîç Debug info:");
      console.log("  - Recipient:", recipient);
      console.log("  - Handle:", handles[0]);
      console.log("  - InputProof length:", inputProof.length);
      console.log("  - InputProof:", inputProof);
      console.log("  - Contract address:", await contract.getAddress());
      console.log("  - Account:", account);

      // Send transaction
      const tx = await contract.sendMessage(recipient, handles[0], inputProof);
      const receipt = await tx.wait();

      // Extract message ID from event
      const event = receipt.logs.find((log: any) => {
        try {
          const parsed = contract.interface.parseLog(log);
          return parsed?.name === "MessageSent";
        } catch {
          return false;
        }
      });

      let messageId = "unknown";
      if (event) {
        const parsed = contract.interface.parseLog(event);
        messageId = parsed?.args?.messageId?.toString() || "unknown";
      }

      console.log(`‚úÖ Message sent! ID: ${messageId}`);

      // Add to local state
      const message: EncryptedMessage = {
        id: messageId,
        sender: account,
        recipient,
        encryptedContent: handles[0],
        timestamp: Date.now(),
        isActive: true,
        status: 'sent',
      };

      setMessages(prev => new Map(prev).set(messageId, message));

      return { success: true, messageId };

    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error("‚ùå Send message failed:", err);
      return { success: false, error: err };
    } finally {
      setIsSending(false);
    }
  }, [contract, fhevmInstance, account, stringToUint256]);

  // Load messages from contract
  const loadMessages = useCallback(async (): Promise<void> => {
    if (!contract || !account) {
      return;
    }

    setIsLoadingMessages(true);

    try {
      console.log("üì• Loading messages...");

      // Get received messages
      const receivedIds = await contract.getReceivedMessages();
      const sentIds = await contract.getSentMessages();
      
      const allIds = [...receivedIds, ...sentIds];
      const uniqueIds = [...new Set(allIds.map(id => id.toString()))];

      console.log(`Found ${uniqueIds.length} messages`);

      const newMessages = new Map<string, EncryptedMessage>();

      // Load message details
      for (const messageId of uniqueIds) {
        try {
          const messageInfo = await contract.getMessageInfo(messageId);
          
          const message: EncryptedMessage = {
            id: messageId,
            sender: messageInfo.sender,
            recipient: messageInfo.recipient,
            encryptedContent: "", // Will be loaded when needed for decryption
            timestamp: Number(messageInfo.timestamp) * 1000, // Convert to milliseconds
            isActive: messageInfo.isActive,
            status: 'sent',
          };

          newMessages.set(messageId, message);
        } catch (error) {
          console.error(`Failed to load message ${messageId}:`, error);
        }
      }

      setMessages(newMessages);
      console.log(`‚úÖ Loaded ${newMessages.size} messages`);

    } catch (error) {
      console.error("‚ùå Failed to load messages:", error);
    } finally {
      setIsLoadingMessages(false);
    }
  }, [contract, account]);

  // Decrypt message content
  const decryptMessage = useCallback(async (
    messageId: string
  ): Promise<{ success: boolean; content?: string; error?: Error }> => {
    if (!contract || !fhevmInstance || !account) {
      return { success: false, error: new Error("Not initialized") };
    }

    const message = messages.get(messageId);
    if (!message) {
      return { success: false, error: new Error("Message not found") };
    }

    // Check if already decrypted
    const existing = decryptedMessages.get(messageId);
    if (existing) {
      return { success: true, content: existing };
    }

    setIsDecrypting(true);

    try {
      console.log(`üîì Decrypting message ${messageId}...`);

      // Get encrypted content handle
      const encryptedContent = await contract.getMessageContent(messageId);
      
      // Get or generate decryption signature
      const contractAddress = await contract.getAddress();
      let sig = await getStoredDecryptionSignature(contractAddress);
      
      if (!sig) {
        console.log("Generating new decryption signature...");
        sig = await generateAndStoreDecryptionSignature(contractAddress);
      }

      if (!sig) {
        throw new Error("Failed to get decryption signature");
      }

      // Decrypt using FHEVM (using reference project approach)
      const decryptedValues = await fhevmInstance.userDecrypt(
        [{ handle: encryptedContent, contractAddress }],
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      console.log("üîç Decryption debug:");
      console.log("  - Decrypted values:", decryptedValues);
      console.log("  - Decrypted values type:", typeof decryptedValues);
      console.log("  - Encrypted content handle:", encryptedContent);

      // Check if decrypted values is an object with handle as key (like reference project)
      let decryptedValue;
      if (typeof decryptedValues === 'object' && decryptedValues !== null && !Array.isArray(decryptedValues)) {
        // Reference project style: res[handle]
        decryptedValue = decryptedValues[encryptedContent];
        console.log("  - Using handle as key:", encryptedContent);
        console.log("  - Decrypted value from handle:", decryptedValue);
      } else if (Array.isArray(decryptedValues) && decryptedValues.length > 0) {
        // Array style: decryptedValues[0]
        decryptedValue = decryptedValues[0];
        console.log("  - Using array index [0]:", decryptedValue);
      } else {
        throw new Error("Invalid decrypted values format");
      }

      if (decryptedValue === undefined || decryptedValue === null) {
        throw new Error("Decrypted value is undefined or null");
      }

      // Convert back to string
      const content = uint256ToString(BigInt(decryptedValue));
      
      // Store decrypted content
      setDecryptedMessages(prev => new Map(prev).set(messageId, content));
      
      console.log(`‚úÖ Message decrypted: "${content}"`);
      
      return { success: true, content };

    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error(`‚ùå Decrypt message ${messageId} failed:`, err);
      return { success: false, error: err };
    } finally {
      setIsDecrypting(false);
    }
  }, [contract, fhevmInstance, account, messages, decryptedMessages, getStoredDecryptionSignature, generateAndStoreDecryptionSignature, uint256ToString]);

  // Block/unblock sender
  const blockSender = useCallback(async (senderAddress: string): Promise<{ success: boolean; error?: Error }> => {
    if (!contract) {
      return { success: false, error: new Error("Contract not initialized") };
    }

    try {
      const tx = await contract.blockSender(senderAddress);
      await tx.wait();
      console.log(`‚úÖ Blocked sender: ${senderAddress}`);
      return { success: true };
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error("‚ùå Block sender failed:", err);
      return { success: false, error: err };
    }
  }, [contract]);

  const unblockSender = useCallback(async (senderAddress: string): Promise<{ success: boolean; error?: Error }> => {
    if (!contract) {
      return { success: false, error: new Error("Contract not initialized") };
    }

    try {
      const tx = await contract.unblockSender(senderAddress);
      await tx.wait();
      console.log(`‚úÖ Unblocked sender: ${senderAddress}`);
      return { success: true };
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error("‚ùå Unblock sender failed:", err);
      return { success: false, error: err };
    }
  }, [contract]);

  // Delete message
  const deleteMessage = useCallback(async (messageId: string): Promise<{ success: boolean; error?: Error }> => {
    if (!contract) {
      return { success: false, error: new Error("Contract not initialized") };
    }

    try {
      const tx = await contract.deleteMessage(messageId);
      await tx.wait();
      
      // Update local state
      setMessages(prev => {
        const updated = new Map(prev);
        const message = updated.get(messageId);
        if (message) {
          updated.set(messageId, { ...message, isActive: false, status: 'deleted' });
        }
        return updated;
      });
      
      console.log(`‚úÖ Deleted message: ${messageId}`);
      return { success: true };
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error("‚ùå Delete message failed:", err);
      return { success: false, error: err };
    }
  }, [contract]);

  // Derived state
  const isReady = contract !== null && fhevmInstance !== null;
  const receivedMessages = Array.from(messages.values()).filter(m => 
    m.recipient.toLowerCase() === account?.toLowerCase() && m.isActive
  );
  const sentMessages = Array.from(messages.values()).filter(m => 
    m.sender.toLowerCase() === account?.toLowerCase() && m.isActive
  );
  const allMessages = Array.from(messages.values()).filter(m => m.isActive);

  // Debug logging
  console.log("üîç Message filtering debug:");
  console.log("  - Account:", account);
  console.log("  - Total messages:", messages.size);
  console.log("  - All messages:", Array.from(messages.values()).map(m => ({
    id: m.id,
    sender: m.sender,
    recipient: m.recipient,
    isActive: m.isActive
  })));
  console.log("  - Received messages:", receivedMessages.length);
  console.log("  - Sent messages:", sentMessages.length);

  return {
    // State
    isReady,
    isInitializing,
    initError,
    contract,
    fhevmInstance,
    
    // Messages
    messages: allMessages,
    receivedMessages,
    sentMessages,
    decryptedMessages,
    
    // Loading states
    isLoadingMessages,
    isSending,
    isDecrypting,
    
    // Actions
    sendMessage,
    loadMessages,
    decryptMessage,
    deleteMessage,
    blockSender,
    unblockSender,
    
    // Utils
    isMessageDecrypted: (messageId: string) => decryptedMessages.has(messageId),
    getDecryptedContent: (messageId: string) => decryptedMessages.get(messageId) || null,
  };
}
